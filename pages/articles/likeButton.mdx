import Layout from '../../components/Layout'

export const meta = {
    id: 'likeButton',
    title: 'いいね（like）機能のシンプルな実装',
    date: '2020-05-20 13:33',
    tags: ['開発日記']
}

## このブログに実装したいいね（like）機能

開発するブログにはいいね機能を付けたいと思っていた。

とはいえ、基本的には私が一方的にコンテンツ（ブログ）を書く静的なウェブサイトなので、DB の導入まではしたくなかった。

そこで、データベースの代わりにファイルシステムを使い、クライアント側ではローカルストレージを使って実装することにした。

### データベースがわりのファイルシステム

各記事のいいね数を記録する json ファイルをファイルシステムで用意し、like / unlike のたびにその json ファイルに記録されているいいね数を増減させていくという発想だ。

各記事のいいね数を取得するための API を用意し、クライアントからその API を叩いていいね数を引っ張ってくる。

### クライアント側（ローカルストレージ）

クライアント側で、各記事にいいねしたかどうかはローカルストレージに保存する。

ローカルストレージの内容を削除してしまえば、いいねした記事がいいねしていない扱いになり、もう一度いいねできてしまうが、そこは手軽さを取って目をつぶる。  
同一ユーザーからの多重いいねを防ごうとすると基本的にはユーザーの認証すなわちユーザー登録機能が必要になってくるはずで、自分ひとりしか書かないブログサイトでそれは無意味だろう。

今回の実装の方針で、つまりファイルシステムにいいね数を記録し、ユーザー認証は付けないという方向性のもとで同一ユーザーからの多重いいねを防ごうとしたら、たとえばいいねを記録するファイル（現状は、いいねされた数字だけを保存している）の
構成を変えて、各行に　いいねしたユーザーの IP アドレス（などの、アプリで作り込んだユーザー認証情報ではないけれどもいちおうユーザーの同一性をかろうじて確認できそうなもの）を保存し、いいね数を増加させる処理の前に、
リクエスト元の IP アドレスがそのファイルに存在しないことを確認する（存在していたらいいね済みである）というような実装になろうか。

#### ローカルストレージとサーバーサイドレンダリング

相性はいいとは言えない。クライアント（ブラウザ）にはもちろんローカルストレージがあるが、サーバーにはローカルストレージは存在しない。  
そのため、何も考えずに書くと、クライアント側とサーバー側で DOM 構造が相違してしまい、ブラウザ側のコンソールに警告が出る。  
一時は、以下のようなコードを書いて、生 DOM を操作してしまうことも考えたが、それはどうなんだという思いが拭えず、やめた。

```js
document.getElementsByClassName("likeButton")[0].innerHTML = getStoredValue(meta.id) === 'liked' ? "<i class='fas fa-heart'></i>" : "<i class='far fa-heart'></i>"
```

結局、以下のような実装にした。  
まず、`lib/localStorage.ts` というモジュールを作り、ローカルストレージからの値読み出し処理をまとめた。

```ts
// localStorage.ts
const getStorage = () => {
  if (typeof window !== 'undefined') {
    try {
      return window.localStorage
    } catch {
      // If localStorage is disabled, ignore the exception caused by reading it
    }
  }
  return {
    // サーバー側であっても、`window.localStorage` と同様に getItem, setItem, removeItem という関数（何もしない関数）を持ったオブジェクトを返す。
    getItem: () => {},
    setItem: () => {},
    removeItem: () => {}
  }
}

const storage = getStorage()

export const getStoredValue = (key: string) => {
  try {
    return storage.getItem(key);
  } catch (e) {
    // Ignore invalid JSON from localStorage
  }
};
```

次に、いいねボタンまわりは以下のようなコードを書いた。  
API からいいね数を取ってくるところや、API を叩いていいね数を増減させるところはどちらも `useEffect` （副作用）を使っている。  
ファイルシステム側のいいね数を増減させるのは、その処理を待たなくて良いが、ファイルシステムからいいね数を取得してくる部分では、その取得処理を待つ必要がある。  
そのため、`async`, `await`, `Promise` を使用している。

いいね数を処理する部分について、`useEffect` を呼ぶ前に関数直下でいいね数を記録する変数（`like`）を用意しておいて、`useEffect` の中で API から取得したいいね数をその変数に素朴に代入しようとしたらどうもうまくいかなかった。  
かわりに、`const [like, setLike] = useState(0)` として state を用意して、`useEffect` の中では、API から取得したいいね数を `setLike` に渡すことでうまくいった。

また、 `useEffect(() => {...}, [like, currentLiked])` のように、`deps` つまり依存する変数を指定（`like` や `currentLiked` の値が変わったら `useEffect` を再実行する）することで、
いいねボタンを押すと数字も増減して画面に表示されるように実装できる。この `deps` の指定によって簡単に再実行条件を記述できるというのはかなり気持ちいい体験だった。

また、いいねボタンは記事画面の左と下両方にあって、どっちから押されたとしても、他方のいいねボタンの色や他方のボタンの下に表示されている数字も変更しないといけない。
これは、現在クライアント側でいいねされているのかどうかを表す状態 `currentLiked` および `setCurrentLiked` を親（`Layout.tsx`）で持ち、それをボタンコンポーネントに pass down し、ボタン側で `currentLiked` を参照して
ボタンの色を出し分けたり、ボタンが押されたら `setCurrentLiked` をコールバックしたり、`currentLiked` を `useEffect` の deps に指定するなどしている。  
（最初はボタンコンポーネントに `currentLiked` の状態を持たせており、左のボタンと下のボタンが独立に動いてしまうようになっていたので、状態を持ち上げ（リフトアップ）た。）

```ts
import React, { useState, useEffect } from 'react'
import { getStoredValue } from '../lib/localStorage'

type Meta = {
    id: string;
    title: string;
    date: string;
    tags: string[];
}

type Props = {
    meta: Meta
    currentLiked: boolean
    setCurrentLiked: React.Dispatch<React.SetStateAction<boolean>>
}

const handleSubmit = (meta: Meta) => {

    let currentLikedOrNot = false
    try {
        currentLikedOrNot = JSON.parse(localStorage.getItem(meta.id) as string).liked
    } catch (err) {
        console.log(err)
    }

    fetch('/api/like', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          "id": `${meta.id}`,
          "currentLikedOrNot" : `${currentLikedOrNot}`
        })
      })
    localStorage.setItem(meta.id, `{ "liked": ${!currentLikedOrNot} }`)
}

const getLike = async (id :string) => {
    const res = await fetch(`/api/like?id=${id}`)
    return res.json()
}

const LikeButton = ({meta, currentLiked, setCurrentLiked} :Props) => {

    const [like, setLike] = useState(0)

    useEffect(() => {
        new Promise((resolve, reject) => {
            resolve(getLike(meta.id))
        }).then(value => {
            setLike(JSON.parse(JSON.stringify(value)).likes)
        })
    }, [like, currentLiked])

    useEffect(() => {
        try {
            setCurrentLiked(JSON.parse(getStoredValue(meta.id) as string)['liked'])
        } catch (err) {
            setCurrentLiked(false)
        } 
    },[])

    return (
        <div className='likeArea'>
        <div className={`heartMark-${currentLiked}`} onClick={() => { handleSubmit(meta); setCurrentLiked(!currentLiked)}}>
            {currentLiked ? <i className='fas fa-heart'></i> : <i className='far fa-heart'></i>}
        </div>
        <span className='howManyLikes'>{like}</span>
        </div>
    )
}

export default LikeButton
```


## ここまでにやったこと

- ✅ シンタックスハイライト
- ✅ テーブルのスタイリング
- ✅ カテゴリタグのデザイン
- ✅ 目次（簡単なロジックでしか組んでいないのでバグありそう）
- ✅ Table of Contents のスタイリング（list-style:none）
- ✅ Warning: Failed prop type: Link: unknown props found: className in Link を倒した（切り出したコンポーネント内で styled jsx 使ったらこのエラー出た。グローバル CSS の中に書き直した）
- ✅ markdown で summary 使ったら warning 発生するのに対処
- ✅ 記事ページのスマホ対応
- ✅ トップページ、スマホで見たら「記事名　日付」のレイアウト崩れる問題に対応
- ✅ いいねボタン（UI）
- ✅ ツイートで共有するボタン
- ✅ 何日前に投稿したかの表示
- ✅ いいねボタン（ロジック）

## これからやること

- カテゴリタグクリックしたらフィルタ結果出す
- 記事の OGP 生成
- はてブ共有ボタン
- コメント機能
- 閲覧数カウンター
- マークダウン内でのツイートや YouTube の埋め込み
- マークダウン内の外部リンク、内部リンクどうなってる？
- favicon
- テスト環境整える（Jest 導入）
- Circle CI 整える
- 本番運用リハーサル

export default ({ children }) => <Layout meta={meta}>{children}</Layout>